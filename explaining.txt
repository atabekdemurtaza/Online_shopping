Предположим, что мы написали весь код, который будет выводить на экран и списки объявлений, разбитые на рубрики, и сведения о выбранном объявлении. И вот
посетитель заходит на сайт, выбирает какую-либо рубрику, пролистывает несколько частей, сформированных пагинатором, находит нужное ему объявление и щелкает на гиперссылке, чтобы просмотреть это объявление полностью. Оrкрывается
страница со сведениями об объявлении, посетитель смотрит их, после чего щелкает
на гиперссылке возврата на список объявлений... И попадает на самую первую
часть этого списка.
То же самое произойдет, если посетитель выполнит поиск, а уже потом отправится
смотреть сведения о каком-либо объявлении. Когда он щелкнет на гиперссьmке
возврата, то вернется в изначальный список объявлений, в котором не бьm выполнен поиск.
Как избежать этой проблемы, в общем, понятно. Номер выводимой части и искомое слово у нас передаются посредством GЕТ-параметров page и keyword соответственно. Тогда, чтобы вернуться на нужную часть списка уже отфильтрованных по
заданному слову объявлений, следует передать эти параметры странице сведений
об объявлении.
Конечно, готовый набор GЕТ-параметров можно получить из элемента с ключом
QUERY_STRING словаря, который хранится в атрибуте МЕТА объекта запроса. Но нет
смысла передавать параметр page, если его значение равно 1 , и параметр keyword
с "пустой" строкой - это их значения по умолчанию.
Также можно формировать набор GЕТ-параметров в контроллере. Но, по принятым
в Django соглашениям, весь код, "ответственный" за формирование страниц, следует помещать в шаблон, посредник или - наш случай! - обработчик контекста.
Огкроем модуль middlewares.py пакета приложения, найдем код обработчика контекста bboard_context_processor(),